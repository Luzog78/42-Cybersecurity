# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    exploitation.py                                    :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: luzog78 <luzog78@gmail.com>                +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/12/15 18:09:58 by luzog78           #+#    #+#              #
#    Updated: 2025/12/17 04:35:12 by luzog78          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

from typing import Any, Callable

from exploits.blind import blind_exploit
from exploits.stacked import stacked_exploit
from exploits.union import union_exploit
from vaccine import InputField, Vaccine, Form, DBServer, print


def exploit(app: Vaccine) -> None:
	print(f'~~~ Starting exploitation phase ~~~')
	print()

	for form in app.forms:
		if len(form.vulnerabilities) == 0:
			continue

		exploits: dict[str, dict[str, dict[str, Any]]] = app.injections['injections']['exploits']
		delimiter: str = app.injections['injections']['delimiter']

		input: InputField | None = None
		db_kind: str | None = None
		for _input, _, _db_kind in form.vulnerabilities:
			if _db_kind is not None:
				db_kind = _db_kind
				input = _input
				break
			elif db_kind is None and _input is not None:
				input = _input

		if db_kind is not None:
			ex = exploits.get(db_kind)
			if ex is None:
				print(f'[!] Cannot exploit form {repr(form.action_url)}: No exploits available for database {repr(db_kind)}')
				continue
			result = exploit_form(
				mode=app.injections_mode,
				headers=app.headers,
				server=app.server,
				db_kind=db_kind,
				input=input,
				exploits=ex,
				delimiter=delimiter,
				form=form,
				verbose=app.verbose,
			)
			if result:
				break

		else:
			for db_kind, ex in exploits.items():
				result = exploit_form(
					mode=app.injections_mode,
					headers=app.headers,
					server=app.server,
					db_kind=db_kind,
					input=input,
					exploits=ex,
					delimiter=delimiter,
					form=form,
					verbose=app.verbose,
				)
				if result:
					break
			else:
				continue
			break

	print()


def exploit_form(
		mode: str,
		headers: dict[str, str],
		server: DBServer,
		db_kind: str,
		input: InputField | None,
		exploits: dict[str, dict[str, Any]],
		delimiter: str,
		form: Form,
		verbose: bool,
		) -> bool:
	print(f'[+] Exploiting form {repr(form.action_url)} with method {repr(form.method)} for database {repr(db_kind)}')
	server.kind = db_kind

	ignored_databases = exploits['ignored_databases']
	assert isinstance(ignored_databases, list)

	def try_exploit(name: str, func: Callable[..., bool]) -> bool:
		if mode in ['all', name] and name in exploits:
			return func(
				headers=headers,
				server=server,
				ignored_databases=ignored_databases,
				payloads=exploits[name],
				delimiter=delimiter,
				form=form,
				input=input,
				verbose=verbose,
			)
		return False

	if try_exploit('stacked', stacked_exploit):
		return True

	if try_exploit('union', union_exploit):
		return True

	if try_exploit('blind', blind_exploit):
		return True

	return False
